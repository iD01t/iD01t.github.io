<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audiobooks - iD01t Productions</title>
    <!-- Assume CSS is linked or inline for simplicity; add your styles here -->
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .filters { display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; }
        #search { padding: 5px; }
        #sort { padding: 5px; }
        #reset, #load-more { padding: 5px 10px; background: #007bff; color: white; border: none; cursor: pointer; }
        #reset:hover, #load-more:hover { background: #0056b3; }
        #catalog { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 20px; }
        .book-item { border: 1px solid #ddd; padding: 10px; text-align: center; }
        .book-item img { max-width: 100px; height: auto; }
        .loading { text-align: center; }
        .error { color: red; }
    </style>
</head>
<body>
    <header>
        <h1>iD01t Productions</h1>
        <nav>
            <a href="/">Store</a>
            <a href="/ebooks">eBooks</a>
            <a href="/audiobooks">Audiobooks</a>
            <a href="/apps">Apps</a>
            <a href="/games">Games</a>
            <a href="/music">Music</a>
            <a href="/blog">Blog</a>
            <a href="/about">About</a>
            <a href="/contact">Contact</a>
        </nav>
        <!-- Theme, Newsletter etc. -->
    </header>

    <main>
        <section>
            <h2>Audiobooks</h2>
            <p>Narrated editions and spoken word, auto populated from Google Books.</p>
            <p>Updated September 06, 2025</p>

            <div class="filters">
                <input type="text" id="search" placeholder="Search audiobooks...">
                <select id="sort">
                    <option value="newest">Newest</option>
                    <option value="oldest">Oldest</option>
                    <option value="title-asc">Title A–Z</option>
                    <option value="title-desc">Title Z–A</option>
                    <!-- Added price sort similar to ebooks, if applicable -->
                    <option value="price-asc">Price ↑</option>
                    <option value="price-desc">Price ↓</option>
                </select>
                <button id="reset">Reset</button>
                <!-- Assuming all languages as default; add select if needed -->
                <select id="language">
                    <option value="">All languages</option>
                    <option value="en">English</option>
                    <!-- Add more if needed -->
                </select>
            </div>

            <div id="catalog"></div>
            <button id="load-more" style="display: none;">Load more</button>
            <div id="status" class="loading" style="display: none;">Loading...</div>
            <div id="error" class="error" style="display: none;"></div>
        </section>
    </main>

    <footer>
        <p>iD01t Productions © All rights reserved</p>
        <a href="/terms">Terms</a>
        <a href="/privacy">Privacy</a>
        <a href="/refunds">Refunds</a>
        <a href="https://github.com/id01t">GitHub</a>
        <a href="https://id01t.itch.io">itch.io</a>
    </footer>

    <script>
        // Replace with your actual Google Books API key
        const API_KEY = 'AIzaSyBpG4uswyDjQXfZbIOfW7hwg2Il0RaUYYs'; // Bulletproof: Check if set
        const BASE_URL = 'https://www.googleapis.com/books/v1/volumes';
        let startIndex = 0;
        const MAX_RESULTS = 20; // Adjustable
        let allBooks = [];
        let currentQuery = ''; // For search
        let currentLang = ''; // For language
        let sortType = 'newest';
        let debounceTimer;

        // Base query for iD01t Productions / Guillaume Lessard audiobooks only
        function getBaseQuery(searchTerm = '', lang = '') {
            let q = 'audiobook (inpublisher:"iD01t Productions" OR inauthor:"Guillaume Lessard")';
            if (searchTerm) {
                q += ` intitle:"${searchTerm}" OR inauthor:"${searchTerm}"`;
            }
            if (lang) {
                q += ` language:"${lang}"`;
            }
            return q;
        }

        async function fetchBooks(append = false, newQuery = '') {
            if (!API_KEY || API_KEY === 'YOUR_GOOGLE_BOOKS_API_KEY_HERE') {
                showError('Google Books API key is not configured. Please set API_KEY in the script.');
                return;
            }

            showStatus('Loading...');
            hideError();

            try {
                const query = newQuery || currentQuery || getBaseQuery();
                const params = new URLSearchParams({
                    q: query,
                    key: API_KEY,
                    startIndex: append ? startIndex.toString() : '0',
                    maxResults: MAX_RESULTS.toString(),
                    orderBy: (sortType === 'newest' || sortType === 'oldest') ? 'newest' : 'relevance', // API only supports newest/relevance; others client-side
                    langRestrict: currentLang || '',
                    projection: 'full',
                    country: 'US' // Adjust as needed
                });

                const url = `${BASE_URL}?${params}`;
                const response = await fetch(url);

                if (!response.ok) {
                    throw new Error(`API request failed: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error.message);
                }

                if (data.items) {
                    const newBooks = data.items
                        .map(item => {
                            const vol = item.volumeInfo || {};
                            const sale = item.saleInfo || {};
                            return {
                                id: item.id,
                                title: vol.title || 'Untitled',
                                authors: vol.authors || [],
                                publisher: vol.publisher || '',
                                publishedDate: vol.publishedDate || 'Unknown',
                                description: vol.description ? vol.description.substring(0, 200) + '...' : '',
                                thumbnail: vol.imageLinks?.thumbnail || '',
                                infoLink: vol.infoLink || '',
                                previewLink: vol.previewLink || '',
                                buyLink: sale.buyLink || vol.infoLink || '',
                                price: sale.listPrice ? `${sale.listPrice.amount} ${sale.listPrice.currencyCode}` : 'N/A',
                                // Bulletproof: Additional check if it's likely audiobook (e.g., "audiobook" in title/subtitle/categories)
                                isAudiobook: vol.title?.toLowerCase().includes('audiobook') || 
                                            (vol.subtitle && vol.subtitle.toLowerCase().includes('audiobook')) ||
                                            (vol.categories && vol.categories.some(cat => cat.toLowerCase().includes('audiobook')))
                            };
                        })
                        .filter(book => book.publisher.includes('iD01t') || book.authors.includes('Guillaume Lessard')) // Extra filter for bulletproof matching
                        .filter(book => !allBooks.some(existing => existing.id === book.id)); // Avoid duplicates

                    if (append) {
                        allBooks = [...allBooks, ...newBooks];
                    } else {
                        allBooks = newBooks;
                    }

                    startIndex += newBooks.length;
                } else {
                    if (!append) allBooks = [];
                }

                renderBooks();
                document.getElementById('load-more').style.display = (data.totalItems > allBooks.length) ? 'block' : 'none';

                if (allBooks.length === 0) {
                    showStatus('No results. Try different filters.');
                } else {
                    hideStatus();
                }
            } catch (error) {
                console.error('Fetch error:', error);
                showError(`Error fetching audiobooks: ${error.message}. Please check your API key and internet connection.`);
                allBooks = [];
                renderBooks();
            }
        }

        function renderBooks() {
            const catalog = document.getElementById('catalog');
            catalog.innerHTML = '';

            if (allBooks.length === 0) {
                catalog.innerHTML = '<p>No results. Try different filters.</p>';
                return;
            }

            const sortedBooks = applySort(allBooks);
            sortedBooks.forEach(book => {
                const item = document.createElement('div');
                item.className = 'book-item';
                item.innerHTML = `
                    ${book.thumbnail ? `<img src="${book.thumbnail}" alt="${book.title} cover" onerror="this.style.display='none'">` : ''}
                    <h3>${escapeHtml(book.title)}</h3>
                    <p>By: ${escapeHtml(book.authors.join(', '))}</p>
                    <p>Publisher: ${escapeHtml(book.publisher)}</p>
                    <p>${escapeHtml(book.description)}</p>
                    ${book.price !== 'N/A' ? `<p>Price: ${escapeHtml(book.price)}</p>` : ''}
                    <a href="${book.buyLink || book.infoLink}" target="_blank">Buy / Preview</a>
                `;
                catalog.appendChild(item);
            });
        }

        function applySort(books) {
            let sorted = [...books];
            const dateParser = (dateStr) => new Date(dateStr.split('-')[0] || '1900-01-01'); // Bulletproof date parse

            switch (sortType) {
                case 'newest':
                    sorted.sort((a, b) => dateParser(b.publishedDate) - dateParser(a.publishedDate));
                    break;
                case 'oldest':
                    sorted.sort((a, b) => dateParser(a.publishedDate) - dateParser(b.publishedDate));
                    break;
                case 'title-asc':
                    sorted.sort((a, b) => a.title.localeCompare(b.title, 'en', { sensitivity: 'base' }));
                    break;
                case 'title-desc':
                    sorted.sort((a, b) => b.title.localeCompare(a.title, 'en', { sensitivity: 'base' }));
                    break;
                case 'price-asc':
                    sorted.sort((a, b) => parseFloat(a.price.replace(/[^0-9.]/g, '')) - parseFloat(b.price.replace(/[^0-9.]/g, '')) || 0);
                    break;
                case 'price-desc':
                    sorted.sort((a, b) => parseFloat(b.price.replace(/[^0-9.]/g, '')) - parseFloat(a.price.replace(/[^0-9.]/g, '')) || 0);
                    break;
                default:
                    // Default to relevance as fetched
                    break;
            }
            return sorted;
        }

        // Bulletproof: Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Event listeners
        document.getElementById('search').addEventListener('input', (e) => {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
                currentQuery = getBaseQuery(e.target.value, currentLang);
                startIndex = 0;
                fetchBooks(false, currentQuery);
            }, 500); // Debounce for bulletproof performance
        });

        document.getElementById('sort').addEventListener('change', (e) => {
            sortType = e.target.value;
            renderBooks(); // Re-sort client-side
        });

        document.getElementById('language').addEventListener('change', (e) => {
            currentLang = e.target.value;
            currentQuery = getBaseQuery(document.getElementById('search').value, currentLang);
            startIndex = 0;
            fetchBooks(false, currentQuery);
        });

        document.getElementById('reset').addEventListener('click', () => {
            document.getElementById('search').value = '';
            document.getElementById('sort').value = 'newest';
            document.getElementById('language').value = '';
            sortType = 'newest';
            currentQuery = '';
            currentLang = '';
            startIndex = 0;
            allBooks = [];
            fetchBooks(false);
        });

        document.getElementById('load-more').addEventListener('click', () => {
            fetchBooks(true);
        });

        // Utility functions for status/error
        function showStatus(msg) {
            document.getElementById('status').textContent = msg;
            document.getElementById('status').style.display = 'block';
        }

        function hideStatus() {
            document.getElementById('status').style.display = 'none';
        }

        function showError(msg) {
            document.getElementById('error').textContent = msg;
            document.getElementById('error').style.display = 'block';
            hideStatus();
        }

        // Initial load
        fetchBooks(false);
    </script>
</body>
</html>
